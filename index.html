<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HANGMAN v4.4.0 (r24 - REGRESSION_FIX)</title>
    <style>
        :root {
            --color-bg-primary: #0A0A0A; --color-surface: #141414; --color-func: #2A2A2A; --color-text-passive: #B0B0B0; --color-text-bright: #FFFFFF; --color-accent-primary: #00FFFF; --color-accent-bios: #00FF8A; --color-error: #FF414B; --color-success: #39FF14; --color-accent-gold: #FFD700; --gap-s: 8px; --gap-m: 16px; --gap-l: 32px;
            --k: clamp(24px, min( (100vw - 32px)/10, (100vh - 200px)/6 ), 64px);
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        html { 
            height: 100%; 
            font-size: clamp(16px, 1.2vw + 0.5rem, 22px);
        }

        body { width: 100%; height: 100%; overflow: hidden; background-color: var(--color-bg-primary); color: var(--color-text-bright); font-family: Consolas, Menlo, Courier New, monospace; font-size: 1rem; position: relative; }
        #perspective-container { perspective: 1200px; width: 100%; height: 100%; position: relative; }
        body::after { content: ""; position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; background: repeating-linear-gradient(0deg, rgba(0,0,0,0.5) 0px, rgba(0,0,0,0.4) 1px, transparent 2px, transparent 3px); z-index: 10; animation: scanline-scroll 20s linear infinite; }
        @keyframes scanline-scroll { to { background-position-y: 100%; } }
        body::before { content: ""; position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; background-image: linear-gradient(var(--color-surface) 1px, transparent 1px), linear-gradient(90deg, var(--color-surface) 1px, transparent 1px); background-size: 40px 40px; opacity: 0.05; z-index: -1; }
        main { width: 100%; height: 100%; position: absolute; top: 0; left: 0; transform-style: preserve-3d; }
        
        .window {
            width: 100%; height: 100%; padding: var(--gap-m) var(--gap-l); position: absolute; top: 0; left: 0;
            display: flex; flex-direction: column; justify-content: space-between; align-items: center; text-align: center; gap: var(--gap-m);
            opacity: 0; transform: translateZ(-200px); pointer-events: none; visibility: hidden;
            transition: opacity 300ms ease-out, transform 300ms ease-out, visibility 300ms;
        }
        .window.active {
            opacity: 1; transform: translateZ(0px); pointer-events: auto; visibility: visible;
        }
        
        #preload, #title, #victory, #gameOver { justify-content: center; }

        h1 { font-size: 4rem; color: var(--color-accent-primary); letter-spacing: 8px; text-shadow: 0 0 5px var(--color-accent-primary), 0 0 15px var(--color-accent-primary), 0 0 25px var(--color-accent-primary); }
        h2 { font-size: 2.5rem; color: var(--color-text-bright); margin-bottom: var(--gap-m); }
        p { font-size: 1.1rem; color: var(--color-text-passive); max-width: 800px; line-height: 1.6; }
        .interactive-button, button { background-color: var(--color-func); border: 2px solid var(--color-surface); color: var(--color-text-bright); padding: var(--gap-s) var(--gap-m); font-family: inherit; font-size: 1.2rem; cursor: pointer; text-transform: uppercase; transition: background-color 220ms, border-color 220ms, color 220ms, opacity 220ms, transform 220ms; }
        .interactive-button:hover, button:hover { background-color: var(--color-surface); border-color: var(--color-accent-primary); }
        .interactive-button:focus-visible, button:focus-visible { outline: 3px solid var(--color-accent-bios); outline-offset: 2px; }
        .interactive-button:disabled, button:disabled { background-color: var(--color-func); border-color: #222; color: #444; cursor: not-allowed; opacity: 0.4; filter: grayscale(80%); transform: scale(0.95); }
        
        .telemetry-header, .telemetry-footer { width: 100%; flex-shrink: 0; text-transform: uppercase; color: var(--color-text-passive); font-size: 0.9rem; letter-spacing: 2px; }
        .telemetry-header { display: flex; justify-content: space-between; align-items: center; padding: var(--gap-s); border-bottom: 1px solid var(--color-surface); }
        .telemetry-footer { padding: var(--gap-s); border-top: 1px solid var(--color-surface); }
        .telemetry-group { display: flex; align-items: center; gap: var(--gap-m); }
        .telemetry-bars { display: flex; gap: var(--gap-s); }
        .telemetry-bar { width: 40px; height: 12px; background: linear-gradient(90deg, var(--color-accent-primary), var(--color-accent-bios)); background-size: 200% 100%; border: 1px solid var(--color-surface); }
        .telemetry-bar.cpu { animation: telemetry-cpu 2s linear infinite; }
        .telemetry-bar.mem { animation: telemetry-mem 3.5s linear infinite; }
        @keyframes telemetry-cpu { 0% { background-position: 0% 0%; } 50% { background-position: 100% 0%; } 100% { background-position: 0% 0%; } }
        @keyframes telemetry-mem { 0% { background-position: 100% 0%; } 50% { background-position: 0% 0%; } 100% { background-position: 100% 0%; } }
        .status-light { width: 10px; height: 10px; background-color: var(--color-success); border-radius: 50%; margin-right: var(--gap-s); animation: blink 1.5s infinite; }
        @keyframes blink { 50% { opacity: 0.3; } }
        #holographic-panel { display: flex; flex-direction: column; align-items: center; justify-content: center; gap: var(--gap-m); transform-style: preserve-3d; transform: rotateX(10deg); transition: transform 0.1s linear; filter: drop-shadow(0 0 15px rgba(0, 255, 255, 0.4)); width: 100%; max-width: 100%; padding: 0 var(--gap-m); }
        @keyframes glitch-error-effect { 0%, 100% { transform: translate(0, 0) rotateX(10deg); filter: drop-shadow(0 0 15px rgba(0, 255, 255, 0.4)) blur(0); } 10% { transform: translate(-5px, -3px) rotateX(10deg) skewX(-5deg); filter: drop-shadow(0 0 15px rgba(255, 0, 0, 0.6)) blur(0.5px); } 30% { transform: translate(3px, 5px) rotateX(10deg) skewX(5deg); } 50% { transform: translate(-3px, -5px) rotateX(10deg); filter: drop-shadow(0 0 25px rgba(255, 0, 0, 0.8)) blur(1px); } 70% { transform: translate(5px, 3px) rotateX(10deg); } 90% { transform: translate(-3px, 3px) rotateX(10deg) skewX(-2deg); filter: drop-shadow(0 0 15px rgba(255, 0, 0, 0.6)) blur(0.5px); } }
        .glitch-active { animation: glitch-error-effect 300ms ease-in-out; }
        #profilesList { list-style: none; margin-bottom: 24px; display: flex; flex-direction: column; gap: var(--gap-s); max-height: 50vh; overflow-y: auto; padding: 0 10px; }
        .profile-entry { display: flex; gap: var(--gap-s); align-items: center; }
        .profile-button { flex-grow: 1; text-align: left; padding-left: 20px;}
        .delete-button { width: 48px; height: 48px; padding: 0; font-size: 1.5rem; flex-shrink: 0; background-color: var(--color-error); border-color: #8B0000; }
        #levelGrid { display: flex; flex-direction: column; gap: var(--gap-m); max-width: 450px; width: 100%; }
        #levelGrid button { padding: var(--gap-m); font-size: 1.5rem; display: flex; align-items: center; }
        .level-button-content { display: flex; justify-content: space-between; align-items: center; width: 100%; }
        .progress-cubes-container { display: grid; grid-template-rows: repeat(2, 1fr); grid-auto-flow: column; gap: 3px; justify-content: flex-end; flex-grow: 1; overflow: hidden; max-height: 23px; }
        @keyframes cube-flicker { 0%, 100% { opacity: 0.8; } 20% { opacity: 0.4; } 22% { opacity: 0.8; } 55% { opacity: 0.35; } 57% { opacity: 0.8; } }
        .progress-cube { width: 10px; height: 10px; border: 1px solid var(--color-surface); background: radial-gradient(circle, var(--color-accent-bios) 0%, rgba(34,139,34,0.7) 100%); opacity: 0.8; flex-shrink: 0; }
        #playerNameDisplay { width: calc(var(--k) * 8 + var(--gap-s) * 7); height: calc(var(--k) * 1.2); background-color: var(--color-surface); border: 2px solid var(--color-func); color: var(--color-accent-primary); font-size: calc(var(--k) * 0.6); display: flex; justify-content: center; align-items: center; letter-spacing: 4px; margin-bottom: var(--gap-m); }
        #virtualKeyboard { display: grid; grid-template-columns: repeat(8, var(--k)); grid-template-rows: repeat(4, var(--k)); gap: var(--gap-s); }
        #virtualKeyboard .key { padding: 0; font-size: calc(var(--k) * 0.5); text-transform: none; }
        .key[data-key="Backspace"] { grid-column: span 1; } .key[data-key="Enter"] { grid-column: span 2; } .key[data-key="Shift"] { grid-column: span 2; }
        
        #gameDefinition { font-size: 1.5rem; color: var(--color-accent-gold); height: 5em; line-height: 1.5; }
        #wordDisplay { display: flex; gap: var(--gap-s); margin: var(--gap-m) 0; flex-wrap: wrap; justify-content: center;}
        .word-letter { width: clamp(28px, 8vw, 50px); height: clamp(34px, 10vw, 60px); font-size: clamp(1.8rem, 7vw, 3.2rem); display: flex; justify-content: center; align-items: center; background-color: var(--color-surface); border-bottom: 4px solid var(--color-accent-primary); color: var(--color-text-bright); }
        .word-letter.space { background-color: transparent; border-bottom: none; }
        
        #gameKeyboard {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: var(--gap-s);
            width: 100%;
            max-width: 900px;
        }

        #gameKeyboard .key {
            aspect-ratio: 1 / 1;
            font-size: clamp(1.2rem, 3vw, 1.8rem);
            padding: 0;
        }

        #mistakesDisplay { display: flex; gap: 6px; margin-bottom: var(--gap-m); }
        .mistake-segment { width: 35px; height: 8px; background-color: var(--color-surface); border: 1px solid var(--color-func); transition: background-color 200ms; }
        .mistake-segment.filled { background-color: var(--color-error); box-shadow: 0 0 5px var(--color-error); }

        .ascii-art-container { width: 120px; height: 120px; margin-bottom: var(--gap-m); }
        .ascii-art { position: relative; width: 100%; height: 100%; }
        .ascii-art div { position: absolute; top: 50%; left: 50%; width: 6px; height: 6px; }
        .ascii-art-victory div { background: var(--color-success); box-shadow: -12px 18px var(--color-success),-18px 12px var(--color-success),-24px 6px var(--color-success),-6px 24px var(--color-success),0 30px var(--color-success),6px 30px var(--color-success),12px 24px var(--color-success),18px 18px var(--color-success),24px 12px var(--color-success),30px 6px var(--color-success); }
        .ascii-art-defeat div { background: var(--color-error); box-shadow: -18px -18px var(--color-error),-12px -18px var(--color-error),-6px -18px var(--color-error),0 -18px var(--color-error),6px -18px var(--color-error),12px -18px var(--color-error),18px -18px var(--color-error),-12px -12px var(--color-error),-6px -12px var(--color-error),6px -12px var(--color-error),12px -12px var(--color-error),-18px -6px var(--color-error),-6px -6px var(--color-error),6px -6px var(--color-error),18px -6px var(--color-error),-18px 0 var(--color-error),-12px 0 var(--color-error),-6px 0 var(--color-error),0 0 var(--color-error),6px 0 var(--color-error),12px 0 var(--color-error),18px 0 var(--color-error),-6px 6px var(--color-error),6px 6px var(--color-error),-12px 12px var(--color-error),-6px 12px var(--color-error),6px 12px var(--color-error),12px 12px var(--color-error),-18px 18px var(--color-error),18px 18px var(--color-error); }
    </style>
</head>
<body>
    <div id="perspective-container">
        <main id="appContainer">
            <div id="preload" class="window active"><H1>CARGANDO...</H1></div>
            <div id="title" class="window"><h1>HANGMAN</h1><p>PRESIONA CUALQUIER TECLA PARA CONTINUAR</p></div>
            <div id="profiles" class="window">
                <header class="telemetry-header"><span>HANGMAN :: SELECT PROFILE</span><div class="telemetry-group"><div class="status-light"></div><span>SYSTEM ONLINE</span></div></header>
                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; flex-grow: 1; width: 100%;"><h2>PERFILES DE USUARIO</h2><ul id="profilesList"></ul><button id="goToPlayerCreateButton" class="interactive-button">CREAR NUEVO PERFIL</button></div>
                <footer class="telemetry-footer">BUILD: v4.4.0-r24</footer>
            </div>
            <div id="player" class="window">
                <header class="telemetry-header"><span>HANGMAN :: CREATE PROFILE</span><div class="telemetry-group"><div class="status-light"></div><span>SYSTEM ONLINE</span></div></header>
                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; flex-grow: 1; width: 100%;"><h2>NUEVO JUGADOR</h2><div id="playerNameDisplay">_</div><div id="virtualKeyboard"></div><div style="display: flex; gap: 16px; margin-top: 16px;"><button id="cancelPlayerButton">CANCELAR</button></div></div>
                <footer class="telemetry-footer">BUILD: v4.4.0-r24</footer>
            </div>
            <div id="mainMenu" class="window">
                <header class="telemetry-header"><span>HANGMAN :: MAIN MENU</span><div class="telemetry-group"><div class="status-light"></div><span>SYSTEM ONLINE</span></div></header>
                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; flex-grow: 1; width: 100%;"><h2 id="mainMenuHeader"></h2><div id="levelGrid"></div><button id="backToProfilesButton" style="margin-top: 16px;">VOLVER A PERFILES</button></div>
                <footer class="telemetry-footer">BUILD: v4.4.0-r24</footer>
            </div>
            <div id="game" class="window">
                <header class="telemetry-header"><span>HANGMAN :: GAME ACTIVE</span><div class="telemetry-group"><span>CPU</span><div class="telemetry-bars"><div class="telemetry-bar cpu"></div></div><span>MEM</span><div class="telemetry-bars"><div class="telemetry-bar mem"></div></div></div></header>
                <div id="holographic-panel">
                    <h2>DESCIFRAR T&Eacute;RMINO</h2>
                    <div id="mistakesDisplay"></div>
                    <p id="gameDefinition"></p>
                    <div id="wordDisplay"></div>
                    <div id="gameKeyboard"></div>
                </div>
                <footer class="telemetry-footer">BUILD: v4.4.0-r24</footer>
            </div>
            <div id="victory" class="window"><div class="ascii-art-container"><div class="ascii-art ascii-art-victory"><div></div></div></div><h1 style="color: var(--color-success);">N&Uacute;CLEO ESTABLE</h1><h2>VICTORIA</h2><p>HAS ADIVINADO EL T&Eacute;RMINO CORRECTAMENTE.</p><button id="victoryToMenuButton">VOLVER AL MEN&Uacute;</button></div>
            <div id="gameOver" class="window"><div class="ascii-art-container"><div class="ascii-art ascii-art-defeat"><div></div></div></div><h1 style="color: var(--color-error);">FALLO CR&Iacute;TICO</h1><h2>DERROTA</h2><p id="gameOverCorrectWord"></p><button id="gameOverToMenuButton">REINTENTAR DESDE EL MEN&Uacute;</button></div>
            <div id="fullscreenOverlay" class="window" style="z-index: 999; background-color: rgba(0,0,0,0.95);"><h2>MODO PANTALLA COMPLETA REQUERIDO</h2><p>PARA UNA EXPERIENCIA &Oacute;PTIMA, EL SISTEMA REQUIERE OPERAR EN MODO DE PANTALLA COMPLETA.</p><button id="reEnterFullscreenButton">REACTIVAR</button></div>
        </main>
    </div>
    <script>
        (function() {
            'use strict';
            document.addEventListener('DOMContentLoaded', function() {
                var state = { currentWindow: 'preload', activeProfile: null, profiles: {}, newPlayerName: '', isShiftActive: false, game: { prngState: 0, sessionPlayedWords: { facil: [], medio: [], dificil: [] }, currentDifficulty: null, difficultyTiers: { facil: [ { term: 'RAM', definition: 'MEMORIA VOL\u00c1TIL DE ACCESO ALEATORIO.' }, { term: 'ROM', definition: 'MEMORIA NO VOL\u00c1TIL DE SOLO LECTURA.' }, { term: 'HDD', definition: 'DISCO DURO MEC\u00c1NICO CON PLATOS GIRATORIOS.' }, { term: 'SSD', definition: 'UNIDAD DE ESTADO S\u00d3LIDO SIN PARTES M\u00d3VILES.' }, { term: 'USB', definition: 'EST\u00c1NDAR DE BUS SERIE UNIVERSAL PARA CONECTAR DISPOSITIVOS.' }, { term: 'RAID', definition: 'CONJUNTO REDUNDANTE DE DISCOS INDEPENDIENTES.' }, { term: 'NUBE', definition: 'ALMACENAMIENTO DE DATOS EN SERVIDORES REMOTOS.' }, { term: 'BIOS', definition: 'SISTEMA B\u00c1SICO DE ENTRADA/SALIDA EN LA PLACA BASE.' }, { term: 'BIT', definition: 'LA UNIDAD DE INFORMACI\u00d3N M\u00c1S PEQUE\u00d1A.' }, { term: 'BYTE', definition: 'CONJUNTO DE 8 BITS QUE REPRESENTA UN CAR\u00c1CTER.' }, { term: 'LAN', definition: 'RED DE \u00c1REA LOCAL.' }, { term: 'WAN', definition: 'RED DE \u00c1REA AMPLIA.' }, { term: 'IP', definition: 'DIRECCI\u00d3N DE PROTOCOLO DE INTERNET.' }, { term: 'MAC', definition: 'DIRECCI\u00d3N DE CONTROL DE ACCESO AL MEDIO.' }, { term: 'DNS', definition: 'SISTEMA DE NOMBRES DE DOMINIO.' }, { term: 'FTP', definition: 'PROTOCOLO DE TRANSFERENCIA DE ARCHIVOS.' }, { term: 'CPU', definition: 'UNIDAD CENTRAL DE PROCESAMIENTO.' }, { term: 'GPU', definition: 'UNIDAD DE PROCESAMIENTO GR\u00c1FICO.' }, { term: 'OS', definition: 'SISTEMA OPERATIVO.' }, { term: 'GUI', definition: 'INTERFAZ GR\u00c1FICA DE USUARIO.' }, { term: 'API', definition: 'INTERFAZ DE PROGRAMACI\u00d3N DE APLICACIONES.' }, { term: 'JSON', definition: 'NOTACI\u00d3N DE OBJETOS DE JAVASCRIPT.' }, { term: 'XML', definition: 'LENGUAJE DE MARCADO EXTENSIBLE.' }, { term: 'HTML', definition: 'LENGUAJE DE MARCADO DE HIPERTEXTO.' }, { term: 'CSS', definition: 'HOJAS DE ESTILO EN CASCADA.' }, { term: 'BUG', definition: 'ERROR O FALLO EN UN PROGRAMA.' }, { term: 'LOG', definition: 'REGISTRO DE EVENTOS DE UN SISTEMA.' }, { term: 'WIFI', definition: 'TECNOLOG\u00cdA DE RED INAL\u00c1MBRICA.' }, { term: 'URL', definition: 'LOCALIZADOR UNIFORME DE RECURSOS.' }, { term: 'PING', definition: 'UTILIDAD PARA PROBAR LA CONECTIVIDAD DE RED.' } ], medio: [ { term: 'CACHE', definition: 'MEMORIA R\u00c1PIDA PARA DATOS DE ACCESO FRECUENTE.' }, { term: 'SECTOR', definition: 'LA SUBDIVISI\u00d3N M\u00c1S PEQUE\u00d1A DE UNA PISTA EN UN DISCO.' }, { term: 'CLUSTER', definition: 'CONJUNTO DE SECTORES DE DISCO TRATADOS COMO UNA UNIDAD.' }, { term: 'BACKUP', definition: 'COPIA DE SEGURIDAD DE DATOS PARA RESTAURACI\u00d3N.' }, { term: 'MEMORIA', definition: 'COMPONENTE QUE ALMACENA DATOS PARA ACCESO R\u00c1PIDO POR LA CPU.' }, { term: 'VOLUMEN', definition: 'UN \u00c1REA DE ALMACENAMIENTO \u00daNICA Y ACCESIBLE CON UN SISTEMA DE ARCHIVOS.' }, { term: 'VIRTUAL', definition: 'MEMORIA QUE SIMULA SER RAM USANDO ESPACIO EN DISCO.' }, { term: 'HIBRIDO', definition: 'UNIDAD DE ALMACENAMIENTO QUE COMBINA HDD Y SSD.' }, { term: 'SATA', definition: 'INTERFAZ PARA CONECTAR DISPOSITIVOS DE ALMACENAMIENTO MASIVO.' }, { term: 'FAT32', definition: 'UN SISTEMA DE ARCHIVOS COM\u00daN PARA UNIDADES EXTRA\u00cdBLES.' }, { term: 'KERNEL', definition: 'N\u00daCLEO DE UN SISTEMA OPERATIVO.' }, { term: 'DRIVER', definition: 'SOFTWARE QUE CONTROLA UN DISPOSITIVO DE HARDWARE.' }, { term: 'ROUTER', definition: 'DISPOSITIVO QUE ENV\u00cdA PAQUETES DE DATOS ENTRE REDES.' }, { term: 'SWITCH', definition: 'DISPOSITIVO QUE CONECTA DISPOSITIVOS EN UNA RED.' }, { term: 'MODEM', definition: 'DISPOSITIVO QUE MODULA Y DEMODULA SE\u00d1ALES.' }, { term: 'CLIENTE', definition: 'APLICACI\u00d3N O SISTEMA QUE ACCEDE A UN SERVICIO EN UN SERVIDOR.' }, { term: 'SERVIDOR', definition: 'SISTEMA QUE PROPORCIONA SERVICIOS A CLIENTES.' }, { term: 'FIREWALL', definition: 'SISTEMA DE SEGURIDAD QUE CONTROLA EL TR\u00c1FICO DE RED.' }, { term: 'CODIGO', definition: 'CONJUNTO DE INSTRUCCIONES PARA UN ORDENADOR.' }, { term: 'SCRIPT', definition: 'PROGRAMA QUE SE INTERPRETA EN LUGAR DE COMPILARSE.' }, { term: 'COMPILAR', definition: 'TRADUCIR C\u00d3DIGO FUENTE A C\u00d3DIGO M\u00c1QUINA.' }, { term: 'VARIABLE', definition: 'ESPACIO EN MEMORIA CON UN NOMBRE Y UN VALOR.' }, { term: 'FUNCION', definition: 'BLOQUE DE C\u00d3DIGO REUTILIZABLE QUE REALIZA UNA TAREA.' }, { term: 'ALGORITMO', definition: 'CONJUNTO DE PASOS PARA RESOLVER UN PROBLEMA.' }, { term: 'FRAMEWORK', definition: 'CONJUNTO DE HERRAMIENTAS Y LIBRER\u00cdAS PARA DESARROLLAR SOFTWARE.' }, { term: 'LIBRERIA', definition: 'COLECCI\u00d3N DE FUNCIONES Y RUTINAS PREESCRITAS.' }, { term: 'BOOLEANO', definition: 'TIPO DE DATO CON VALORES VERDADERO O FALSO.' }, { term: 'ITERAR', definition: 'REPETIR UN PROCESO O CONJUNTO DE INSTRUCCIONES.' }, { term: 'RECURSION', definition: 'T\u00c9CNICA DONDE UNA FUNCI\u00d3N SE LLAMA A S\u00cd MISMA.' }, { term: 'DEPURAR', definition: 'PROCESO DE ENCONTRAR Y CORREGIR ERRORES.' } ], dificil: [ { term: 'PARTICION', definition: 'DIVISI\u00d3N L\u00d3GICA DE UNA UNIDAD DE ALMACENAMIENTO F\u00cdSICA.' }, { term: 'VOLATIL', definition: 'TIPO DE MEMORIA QUE PIERDE SUS DATOS CUANDO SE CORTA LA ENERG\u00cdA.' }, { term: 'SECUENCIAL', definition: 'ACCESO A DATOS QUE SE REALIZA EN UN ORDEN PREDETERMINADO.' }, { term: 'PERSISTENCIA', definition: 'LA CARACTER\u00cdSTICA DE LOS DATOS QUE SOBREVIVEN DESPU\u00c9S DE QUE EL PROCESO TERMINA.' }, { term: 'REDUNDANCIA', definition: 'DUPLICACI\u00d3N DE COMPONENTES O DATOS CR\u00cdTICOS PARA AUMENTAR LA FIABILIDAD.' }, { term: 'ENCRIPTACION', definition: 'PROCESO DE CODIFICAR DATOS PARA QUE SOLO PARTES AUTORIZADAS PUEDAN LEERLOS.' }, { term: 'INSTANTANEA', definition: 'COPIA DEL ESTADO DE UN SISTEMA EN UN MOMENTO DETERMINADO, TAMBI\u00c9N LLAMADA SNAPSHOT.' }, { term: 'JERARQUICO', definition: 'MODELO DE SISTEMA DE ARCHIVOS QUE ORGANIZA DATOS EN UNA ESTRUCTURA DE \u00c1RBOL.' }, { term: 'DESFRAGMENTAR', definition: 'PROCESO DE REORGANIZAR LOS DATOS EN UN DISCO PARA QUE LAS PARTES DE CADA ARCHIVO EST\u00c9N CONTIGUAS.' }, { term: 'ALMACENAMIENTO', definition: 'RETENCI\u00d3N DE DATOS RECUPERABLES EN MEDIOS DIGITALES.' }, { term: 'VIRTUALIZACION', definition: 'CREACI\u00d3N DE UNA VERSI\u00d3N VIRTUAL DE ALGO, COMO UN SERVIDOR O SISTEMA OPERATIVO.' }, { term: 'CONTENEDOR', definition: 'UNIDAD EST\u00c1NDAR DE SOFTWARE QUE EMPAQUETA C\u00d3DIGO Y SUS DEPENDENCIAS.' }, { term: 'ORQUESTACION', definition: 'AUTOMATIZACI\u00d3N DE LA GESTI\u00d3N, COORDINACI\u00d3N Y DESPLIEGE DE CONTENEDORES.' }, { term: 'MICROSERVICIOS', definition: 'ARQUITECTURA DONDE UNA APLICACI\u00d3N SE COMPONE DE PEQUE\u00d1OS SERVICIOS INDEPENDIENTES.' }, { term: 'AUTENTICACION', definition: 'PROCESO DE VERIFICAR LA IDENTIDAD DE UN USUARIO.' }, { term: 'AUTORIZACION', definition: 'PROCESO DE OTORGAR PERMISOS A UN USUARIO AUTENTICADO.' }, { term: 'PROTOCOLO', definition: 'CONJUNTO DE REGLAS QUE GOBIERNAN LA COMUNICACI\u00d3N DE DATOS.' }, { term: 'LATENCIA', definition: 'RETRASO EN LA TRANSMISI\u00d3N DE DATOS EN UNA RED.' }, { term: 'ANCHO DE BANDA', definition: 'CAPACIDAD M\u00c1XIMA DE TRANSFERENCIA DE DATOS DE UNA RED.' }, { term: 'POLIMORFISMO', definition: 'CONCEPTO DE PROGRAMACI\u00d3N ORIENTADA A OBJETOS PARA PROCESAR OBJETOS DE FORMA DIFERENTE SEG\u00daN SU TIPO.' }, { term: 'HERENCIA', definition: 'MECANISMO POR EL CUAL UNA CLASE ADQUIERE PROPIEDADES DE OTRA CLASE.' }, { term: 'ENCAPSULACION', definition: 'OCULTACI\u00d3N DE LOS DETALLES INTERNOS DE UN OBJETO Y EXPOSICI\u00d3N DE UNA INTERFAZ P\u00daBLICA.' }, { term: 'ABSTRACCION', definition: 'PROCESO DE SIMPLIFICAR SISTEMAS COMPLEJOS MOSTRANDO SOLO LA INFORMACI\u00d3N RELEVANTE.' }, { term: 'COMPILADOR JIT', definition: 'COMPILADOR "JUST-IN-TIME" QUE COMPILA C\u00d3DIGO DURANTE LA EJECUCI\u00d3N.' }, { term: 'RECOLECCION DE BASURA', definition: 'FORMA DE GESTI\u00d3N AUTOM\u00c1TICA DE MEMORIA.' }, { term: 'HILO DE EJECUCION', definition: 'LA SECUENCIA M\u00c1S PEQUE\u00d1A DE INSTRUCCIONES PROGRAMADAS QUE PUEDE SER GESTIONADA DE FORMA INDEPENDIENTE.' }, { term: 'INTERBLOQUEO', definition: 'SITUACI\u00d3N EN LA QUE DOS O M\u00c1S PROCESOS SE BLOQUEAN MUTUAMENTE, ESPERANDO RECURSOS.' }, { term: 'SEMAFORO', definition: 'VARIABLE UTILIZADA PARA CONTROLAR EL ACCESO A UN RECURSO COM\u00daN POR M\u00daLTIPLES PROCESOS.' }, { term: 'CRIPTOGRAFIA', definition: 'PR\u00c1CTICA Y ESTUDIO DE T\u00c9CNICAS PARA LA COMUNICACI\u00d3N SEGURA.' }, { term: 'ESTEGANOGRAFIA', definition: 'T\u00c9CNICA DE OCULTAR MENSAJES DENTRO DE OTROS OBJETOS O ARCHIVOS.' } ] }, currentWord: '', currentDefinition: '', guessedLetters: [], mistakes: 0, maxMistakes: 6, isOver: false } };
                var windows = { preload: document.getElementById('preload'), title: document.getElementById('title'), profiles: document.getElementById('profiles'), player: document.getElementById('player'), mainMenu: document.getElementById('mainMenu'), game: document.getElementById('game'), victory: document.getElementById('victory'), gameOver: document.getElementById('gameOver'), fullscreenOverlay: document.getElementById('fullscreenOverlay') };
                var ui = { levelGrid: document.getElementById('levelGrid'), profilesList: document.getElementById('profilesList'), goToPlayerCreateButton: document.getElementById('goToPlayerCreateButton'), mainMenuHeader: document.getElementById('mainMenuHeader'), backToProfilesButton: document.getElementById('backToProfilesButton'), playerNameDisplay: document.getElementById('playerNameDisplay'), virtualKeyboard: document.getElementById('virtualKeyboard'), cancelPlayerButton: document.getElementById('cancelPlayerButton'), gameDefinition: document.getElementById('gameDefinition'), wordDisplay: document.getElementById('wordDisplay'), gameKeyboard: document.getElementById('gameKeyboard'), victoryToMenuButton: document.getElementById('victoryToMenuButton'), gameOverToMenuButton: document.getElementById('gameOverToMenuButton'), gameOverCorrectWord: document.getElementById('gameOverCorrectWord'), reEnterFullscreenButton: document.getElementById('reEnterFullscreenButton'), holographicPanel: document.getElementById('holographic-panel'), mistakesDisplay: document.getElementById('mistakesDisplay') };
                var PLAYER_KEYBOARD_LAYOUT = ['Q','W','E','R','T','Y','U','Backspace','A','S','D','F','G','H','Enter','I','J','K','L','M','\u00d1','O','P','Shift','Z','X','C','V','B','N'];
                var GAME_KEYBOARD_CHARS = 'ABCDEFGHIJKLMN\u00d1OPQRSTUVWXYZ';
                var STORAGE_KEY = 'analyzer:profiles';
                function saveProfilesToStorage() { try { localStorage.setItem(STORAGE_KEY, JSON.stringify(state.profiles)); } catch (e) { console.error('[ERR][STORAGE] FALLO AL GUARDAR PERFILES.', e); } }
                function loadProfilesFromStorage() { try { var storedData = JSON.parse(localStorage.getItem(STORAGE_KEY)); if (!storedData) { state.profiles = {}; return; } if (Array.isArray(storedData)) { console.warn('[STORAGE][MIGRATE] Detectado formato de datos antiguo. Migrando...'); var newProfiles = {}; storedData.forEach(function(profileName) { newProfiles[profileName] = { solvedWords: { facil: [], medio: [], dificil: [] } }; }); state.profiles = newProfiles; saveProfilesToStorage(); } else { state.profiles = storedData; } } catch (e) { console.error('[ERR][STORAGE] FALLO AL CARGAR PERFILES.', e); state.profiles = {}; } }
                
                function showWindow(windowId) {
                    for (var id in windows) {
                        windows[id].classList.remove('active');
                    }
                    windows[windowId].classList.add('active');
                    state.currentWindow = windowId;
                }

                function requestFullscreen() { var elem = document.documentElement; if (elem.requestFullscreen) { elem.requestFullscreen(); } else if (elem.mozRequestFullScreen) { elem.mozRequestFullScreen(); } else if (elem.webkitRequestFullscreen) { elem.webkitRequestFullscreen(); } else if (elem.msRequestFullscreen) { elem.msRequestFullscreen(); } }
                function handleFullscreenChange() { var isFullscreen = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement; if (!isFullscreen && state.currentWindow !== 'preload' && state.currentWindow !== 'title') { windows.fullscreenOverlay.classList.add('active'); } else { windows.fullscreenOverlay.classList.remove('active'); } }
                function renderPlayerKeyboard() { ui.virtualKeyboard.innerHTML = ''; PLAYER_KEYBOARD_LAYOUT.forEach(function(key) { var keyElement = document.createElement('button'); keyElement.className = 'interactive-button key'; keyElement.setAttribute('data-key', key); var displayText = key; if (key === 'Backspace') displayText = '<-'; else if (key === 'Enter') displayText = 'ENTR'; else if (key === 'Shift') { displayText = 'SHFT'; if (state.isShiftActive) keyElement.classList.add('active'); } keyElement.textContent = displayText; ui.virtualKeyboard.appendChild(keyElement); }); }
                function renderProfiles() { ui.profilesList.innerHTML = ''; Object.keys(state.profiles).forEach(function(profileName) { var listItem = document.createElement('li'); listItem.className = 'profile-entry'; var profileButton = document.createElement('button'); profileButton.className = 'interactive-button profile-button'; profileButton.textContent = profileName; profileButton.setAttribute('data-profile-name', profileName); var deleteButton = document.createElement('button'); deleteButton.className = 'delete-button'; deleteButton.textContent = 'X'; deleteButton.setAttribute('data-profile-name', profileName); listItem.appendChild(profileButton); listItem.appendChild(deleteButton); ui.profilesList.appendChild(listItem); }); }
                function renderLevelProgress() { if (!state.activeProfile || !state.profiles[state.activeProfile]) return; var solvedData = state.profiles[state.activeProfile].solvedWords; document.querySelectorAll('#levelGrid button').forEach(function(button) { var difficulty = button.getAttribute('data-difficulty'); var container = button.querySelector('.progress-cubes-container'); if (!difficulty || !container || !solvedData[difficulty]) return; container.innerHTML = ''; var solvedCount = solvedData[difficulty].length; for (var i = 0; i < solvedCount; i++) { var cube = document.createElement('div'); cube.className = 'progress-cube'; if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) { cube.style.animation = 'cube-flicker 4s infinite'; cube.style.animationDelay = '-' + Math.random() * 4 + 's'; } container.appendChild(cube); } }); }
                function populateLevelGrid() { ui.levelGrid.innerHTML = ''; Object.keys(state.game.difficultyTiers).forEach(function(difficulty) { var levelButton = document.createElement('button'); levelButton.className = 'interactive-button'; levelButton.setAttribute('data-difficulty', difficulty); var content = document.createElement('div'); content.className = 'level-button-content'; var text = document.createElement('span'); text.textContent = 'NIVEL ' + difficulty.toUpperCase(); var cubes = document.createElement('div'); cubes.className = 'progress-cubes-container'; content.appendChild(text); content.appendChild(cubes); levelButton.appendChild(content); ui.levelGrid.appendChild(levelButton); }); }
                
                var GameManager = {
                    xorshift32: function(seed) { var x = seed; x ^= x << 13; x ^= x >> 17; x ^= x << 5; return x; },
                    getRandomInt: function(max) { state.game.prngState = this.xorshift32(state.game.prngState); return (state.game.prngState & 0x7FFFFFFF) % max; },
                    startGame: function(difficulty) {
                        var wordList = state.game.difficultyTiers[difficulty];
                        var playedWords = state.game.sessionPlayedWords[difficulty];
                        var availableWords = wordList.filter(function(wordObj) { return playedWords.indexOf(wordObj.term) === -1; });
                        if (availableWords.length === 0) { state.game.sessionPlayedWords[difficulty] = []; availableWords = wordList; }
                        var randomIndex = this.getRandomInt(availableWords.length);
                        var gameData = availableWords[randomIndex];
                        
                        state.game.sessionPlayedWords[difficulty].push(gameData.term);
                        state.game.currentWord = gameData.term;
                        state.game.currentDifficulty = difficulty;
                        state.game.currentDefinition = gameData.definition;
                        state.game.guessedLetters = [];
                        state.game.mistakes = 0;
                        state.game.isOver = false;
                        
                        ui.gameDefinition.textContent = state.game.currentDefinition;
                        this.renderWordDisplay();
                        this.renderGameKeyboard();
                        this.renderMistakesDisplay();
                        showWindow('game');
                    },
                    handleGuess: function(letter) {
                        if (state.game.isOver || state.game.guessedLetters.indexOf(letter) !== -1) return;
                        
                        state.game.guessedLetters.push(letter);
                        var isCorrect = state.game.currentWord.indexOf(letter) !== -1;
                        
                        if (isCorrect) {
                            this.renderWordDisplay();
                        } else {
                            state.game.mistakes++;
                            this.renderMistakesDisplay();
                            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                                ui.holographicPanel.classList.add('glitch-active');
                                ui.holographicPanel.style.animationDuration = (300 - (state.game.mistakes * 40)) + 'ms';
                                setTimeout(function() { ui.holographicPanel.classList.remove('glitch-active'); }, 300);
                            } else {
                                document.body.style.backgroundColor = 'var(--color-error)';
                                setTimeout(function(){ document.body.style.backgroundColor = 'var(--color-bg-primary)'; }, 150);
                            }
                        }
                        this.renderGameKeyboard();
                        this.checkGameState();
                    },
                    checkGameState: function() {
                        var wordSolved = true;
                        for(var i = 0; i < state.game.currentWord.length; i++) {
                            var char = state.game.currentWord[i];
                            if(char !== ' ' && state.game.guessedLetters.indexOf(char) === -1) {
                                wordSolved = false;
                                break;
                            }
                        }
                        if (wordSolved) {
                            this.endGame(true);
                        } else if (state.game.mistakes >= state.game.maxMistakes) {
                            this.endGame(false);
                        }
                    },
                    endGame: function(didWin) {
                        state.game.isOver = true;
                        if (didWin) {
                            var profile = state.profiles[state.activeProfile];
                            var solvedList = profile.solvedWords[state.game.currentDifficulty];
                            if (solvedList.indexOf(state.game.currentWord) === -1) {
                                solvedList.push(state.game.currentWord);
                                saveProfilesToStorage();
                            }
                        }
                        setTimeout(function() {
                            if (didWin) {
                                showWindow('victory');
                            } else {
                                ui.gameOverCorrectWord.textContent = 'EL T\u00c9RMINO ERA: ' + state.game.currentWord;
                                showWindow('gameOver');
                            }
                        }, 500);
                    },
                    renderWordDisplay: function() {
                        ui.wordDisplay.innerHTML = '';
                        state.game.currentWord.split('').forEach(function(char) {
                            var letterDiv = document.createElement('div');
                            letterDiv.className = 'word-letter';
                            if (char === ' ') {
                                letterDiv.classList.add('space');
                            } else {
                                letterDiv.textContent = state.game.guessedLetters.indexOf(char) !== -1 ? char : '';
                            }
                            ui.wordDisplay.appendChild(letterDiv);
                        });
                    },
                    renderGameKeyboard: function() {
                        ui.gameKeyboard.innerHTML = '';
                        GAME_KEYBOARD_CHARS.split('').forEach(function(char) {
                            var keyButton = document.createElement('button');
                            keyButton.className = 'interactive-button key';
                            keyButton.textContent = char;
                            keyButton.setAttribute('data-key', char);
                            if (state.game.guessedLetters.indexOf(char) !== -1) {
                                keyButton.disabled = true;
                            }
                            ui.gameKeyboard.appendChild(keyButton);
                        });
                    },
                    renderMistakesDisplay: function() {
                        ui.mistakesDisplay.innerHTML = '';
                        for (var i = 0; i < state.game.maxMistakes; i++) {
                            var segment = document.createElement('div');
                            segment.className = 'mistake-segment';
                            if (i < state.game.mistakes) {
                                segment.classList.add('filled');
                            }
                            ui.mistakesDisplay.appendChild(segment);
                        }
                    }
                };

                function init() {
                    console.log('[BOOT][INFO] INICIALIZANDO HANGMAN v4.4.0-r24 (REGRESSION_FIX)...');
                    state.game.prngState = new Date().getTime();
                    loadProfilesFromStorage(); populateLevelGrid(); renderProfiles(); renderPlayerKeyboard();
                    setTimeout(function() { showWindow('title'); }, 1000);
                    function advanceToProfiles() { requestFullscreen(); showWindow('profiles'); windows.title.removeEventListener('click', advanceToProfiles); document.removeEventListener('keydown', advanceToProfiles); }
                    windows.title.addEventListener('click', advanceToProfiles);
                    document.addEventListener('keydown', advanceToProfiles);
                    document.addEventListener('fullscreenchange', handleFullscreenChange); document.addEventListener('webkitfullscreenchange', handleFullscreenChange); document.addEventListener('mozfullscreenchange', handleFullscreenChange); document.addEventListener('MSFullscreenChange', handleFullscreenChange);
                    ui.reEnterFullscreenButton.addEventListener('click', function() { requestFullscreen(); windows.fullscreenOverlay.classList.remove('active'); });
                    if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                        document.body.addEventListener('mousemove', function(e) {
                            var x = (e.clientX / window.innerWidth) - 0.5;
                            var y = (e.clientY / window.innerHeight) - 0.5;
                            var maxRotate = 5;
                            var rotateX = y * maxRotate * -1;
                            var rotateY = x * maxRotate;
                            if(ui.holographicPanel) { ui.holographicPanel.style.transform = 'rotateX(' + (10 + rotateX) + 'deg) rotateY(' + rotateY + 'deg)'; }
                        });
                    }
                    ui.goToPlayerCreateButton.addEventListener('click', function() { state.newPlayerName = ''; state.isShiftActive = false; document.getElementById('playerNameDisplay').textContent = '_'; showWindow('player'); });
                    ui.profilesList.addEventListener('click', function(e) { var profileName = e.target.getAttribute('data-profile-name'); if (!profileName) return; if (e.target.classList.contains('profile-button')) { state.activeProfile = profileName; ui.mainMenuHeader.textContent = 'JUGADOR: ' + profileName; renderLevelProgress(); showWindow('mainMenu'); } else if (e.target.classList.contains('delete-button')) { delete state.profiles[profileName]; saveProfilesToStorage(); renderProfiles(); } });
                    ui.virtualKeyboard.addEventListener('click', function(e) { var key = e.target.getAttribute('data-key'); if (!key || !e.target.classList.contains('key')) return; if (key === 'Backspace') { state.newPlayerName = state.newPlayerName.slice(0, -1); } else if (key === 'Enter') { var newName = state.newPlayerName.trim(); if (newName && !state.profiles[newName]) { state.profiles[newName] = { solvedWords: { facil: [], medio: [], dificil: [] } }; saveProfilesToStorage(); renderProfiles(); showWindow('profiles'); } } else if (key === 'Shift') { state.isShiftActive = !state.isShiftActive; renderPlayerKeyboard(); } else { if (state.newPlayerName.length < 12) { var character = state.isShiftActive ? key.toLowerCase() : key.toUpperCase(); state.newPlayerName += character; } } document.getElementById('playerNameDisplay').textContent = state.newPlayerName || '_'; });
                    ui.cancelPlayerButton.addEventListener('click', function() { showWindow('profiles'); });
                    ui.backToProfilesButton.addEventListener('click', function() { state.activeProfile = null; showWindow('profiles'); });
                    ui.levelGrid.addEventListener('click', function(e) { var button = e.target.closest('button[data-difficulty]'); if (button) { GameManager.startGame(button.getAttribute('data-difficulty')); } });
                    ui.gameKeyboard.addEventListener('click', function(e) { if (e.target.hasAttribute('data-key')) { GameManager.handleGuess(e.target.getAttribute('data-key')); } });
                    ui.victoryToMenuButton.addEventListener('click', function() { renderLevelProgress(); showWindow('mainMenu'); });
                    ui.gameOverToMenuButton.addEventListener('click', function() { showWindow('mainMenu'); });
                    console.log('[BOOT][INFO] PREFLIGHT OK. SISTEMA TOTALMENTE COMPATIBLE CON MANIFIESTO.');
                }
                init();
            });
        })();
    </script>
</body>
</html>
